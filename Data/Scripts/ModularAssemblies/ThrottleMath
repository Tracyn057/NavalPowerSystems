public static float GetTableValue(EfficiencyPoint[] table, float currentThrottle)
{
    // 1. Handle out-of-bounds
    if (currentThrottle <= table[0].Throttle) return table[0].Multiplier;
    if (currentThrottle >= table[table.Length - 1].Throttle) return table[table.Length - 1].Multiplier;

    // 2. Find the two points we are between
    for (int i = 0; i < table.Length - 1; i++)
    {
        if (currentThrottle <= table[i + 1].Throttle)
        {
            EfficiencyPoint p1 = table[i];
            EfficiencyPoint p2 = table[i + 1];

            // 3. Calculate the percentage between p1 and p2 (0.0 to 1.0)
            float t = (currentThrottle - p1.Throttle) / (p2.Throttle - p1.Throttle);

            // 4. Linear Interpolation (Lerp)
            return p1.Multiplier + t * (p2.Multiplier - p1.Multiplier);
        }
    }
    return 1.0f; // Fallback
}


// Inside Engine Logic Update10
public void UpdateFuelConsumption(float throttle)
{
    // Get the efficiency multiplier from our C# "Config" table
    float burnMultiplier = GetTableValue(EngineConfigs.DieselFuelTable, throttle);
    
    // Calculate final fuel to remove from the "Tank"
    float fuelToBurn = (BaseBurnRate * burnMultiplier) * (10f / 60f); // Adjust for Update10
    ConsumeFuel(fuelToBurn);
}



public static class NavalTelegraph
{
    public const float STOP = 0.00f;
    public const float SLOW = 0.05f;
    public const float ONE_THIRD = 0.33f;
    public const float STANDARD = 0.50f; // 90% speed at 50% power
    public const float TWO_THIRDS = 0.66f;
    public const float FULL = 1.00f;     // 100% Rated Power
    public const float EMERGENCY = 1.25f; // Overdrive
}




// Simple way to simulate the hull resistance without a full table
float effectiveThrust = (float)Math.Pow(currentThrottle, 0.5); 
// Result: 0.50 throttle (Standard) yields ~0.70 thrust.
// Result: 1.00 throttle (Full) yields 1.00 thrust.




public void SetThrottle(float value)
{
    if (value > NavalTelegraph.FULL && !SafetyOverrideActive)
    {
        _currentThrottle = NavalTelegraph.FULL;
        // Notify player: "Safety Interlock Active"
    }
    else
    {
        _currentThrottle = value;
    }
}




// Inside DrivetrainLogic Update10 (Cruise Mode)
float currentSpeed = (float)Entity.Physics.LinearVelocity.Length();
float speedDelta = TargetSpeed - currentSpeed;

// If we are too slow, nudge the throttle up. If too fast, nudge it down.
// 0.01f is the "sensitivity" of the governor.
if (Math.Abs(speedDelta) > 0.1f) 
{
    _autoThrottle += speedDelta * 0.01f;
    _autoThrottle = MathHelper.Clamp(_autoThrottle, 0f, SafetyOverride ? 1.25f : 1.0f);
}



// Inside Update10
if (CruiseModeActive)
{
    float currentSpeed = (float)Entity.Physics.LinearVelocity.Length();
    float error = TargetSpeed - currentSpeed;

    // Proportional gain: How hard we push back based on speed difference
    // We use a small gain to keep the movement "heavy" and naval
    float adjustment = error * 0.05f; 
    
    // Update the Internal Throttle
    _internalThrottle = MathHelper.Clamp(_internalThrottle + adjustment, 0f, 1.0f);
}




// Simple conversion constants
const float MS_TO_KNOTS = 1.94384f;
const float KNOTS_TO_MS = 0.514444f;

public string GetSpeedDisplay(float speedInMS)
{
    float speedInKnots = speedInMS * MS_TO_KNOTS;
    return $"{speedInKnots:F1} KN ({speedInMS:F1} M/S)";
}







public void ParseSpeedInput(string input)
{
    float parsedValue;
    string cleanInput = input.ToLower().Trim();

    if (cleanInput.Contains("kn") || cleanInput.Contains("kts"))
    {
        // Remove the letters to leave just the number
        string numericPart = cleanInput.Replace("kn", "").Replace("kts", "").Trim();
        if (float.TryParse(numericPart, out parsedValue))
        {
            _targetSpeedMS = parsedValue * 0.514444f;
        }
    }
    else
    {
        // Treat as raw m/s
        if (float.TryParse(cleanInput, out parsedValue))
        {
            _targetSpeedMS = parsedValue;
        }
    }
}







public void ParseSpeedInput(string input)
{
    float parsedValue;
    string cleanInput = input.ToLower().Trim();

    if (cleanInput.Contains("kn") || cleanInput.Contains("kts"))
    {
        // Remove the letters to leave just the number
        string numericPart = cleanInput.Replace("kn", "").Replace("kts", "").Trim();
        if (float.TryParse(numericPart, out parsedValue))
        {
            _targetSpeedMS = parsedValue * 0.514444f;
        }
    }
    else
    {
        // Treat as raw m/s
        if (float.TryParse(cleanInput, out parsedValue))
        {
            _targetSpeedMS = parsedValue;
        }
    }
}
